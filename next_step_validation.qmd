---
title: "Validating the next step ahead predictions"
subtitle: "To compare the predictions of the deepSSF model with predictions of typical SSFs"
author: "Scott Forrest"
date: "`r Sys.Date()`"
execute: 
  cache: false
bibliography: references.bib
toc: true
number-sections: false
format: 
  html:
    self-contained: true
    code-fold: show
    code-tools: true
    df-print: paged
    code-line-numbers: true
    code-overflow: scroll
    fig-format: png
    fig-dpi: 300
  pdf:
    geometry: 
      - top=30mm
      - left=30mm
editor:
  source
---

## Loading packages

```{r}
#| warning=FALSE

library(tidyverse)
packages <- c("amt", "sf", "terra", "beepr", "tictoc", "circular", "matrixStats", "progress")
walk(packages, require, character.only = T)

```

## Import data and clean

```{r}

buffalo <- read_csv("data/buffalo.csv")

# remove individuals that have poor data quality or less than about 3 months of data. 
# The "2014.GPS_COMPACT copy.csv" string is a duplicate of ID 2024, so we exlcude it
buffalo <- buffalo %>% filter(!node %in% c("2014.GPS_COMPACT copy.csv", 
                                           # 2005, 2014, 2018, 2021, 2022, 2024,
                                           2029, 2043, 2265, 2284, 2346, 2354))

buffalo <- buffalo %>%  
  group_by(node) %>% 
  arrange(DateTime, .by_group = T) %>% 
  distinct(DateTime, .keep_all = T) %>% 
  arrange(node) %>% 
  mutate(ID = node)

buffalo_clean <- buffalo[, c(12, 2, 4, 3)]
colnames(buffalo_clean) <- c("id", "time", "lon", "lat")
attr(buffalo_clean$time, "tzone") <- "Australia/Queensland"
head(buffalo_clean)
tz(buffalo_clean$time)

buffalo_ids <- unique(buffalo_clean$id)

```

## Setup trajectory

Use the `amt` package to create a trajectory object from the cleaned data. 

```{r}

buffalo_all <- buffalo_clean %>% mk_track(id = id,
                                           lon,
                                           lat, 
                                           time, 
                                           all_cols = T,
                                           crs = 4326) %>% 
  transform_coords(crs_to = 3112, crs_from = 4326) %>% arrange(id) # Transformation to GDA94 / 
# Geoscience Australia Lambert (https://epsg.io/3112)


```

## Plot the data coloured by time

```{r}

buffalo_all %>%
  ggplot(aes(x = x_, y = y_, colour = t_)) +
  geom_point(alpha = 0.25, size = 1) + 
  coord_fixed() +
  scale_colour_viridis_c() +
  theme_classic()

```

## Reading in the environmental covariates

```{r}

ndvi_projected <- rast("mapping/cropped rasters/ndvi_GEE_projected_watermask20230207.tif")
terra::time(ndvi_projected) <- as.POSIXct(lubridate::ymd("2018-01-01") + months(0:23))
slope <- rast("mapping/cropped rasters/slope_raster.tif")
veg_herby <- rast("mapping/cropped rasters/veg_herby.tif")
canopy_cover <- rast("mapping/cropped rasters/canopy_cover.tif")

# change the names (these will become the column names when extracting 
# covariate values at the used and random steps)
names(ndvi_projected) <- rep("ndvi", terra::nlyr(ndvi_projected))
names(slope) <- "slope"
names(veg_herby) <- "veg_herby"
names(canopy_cover) <- "canopy_cover"

# to plot the rasters
plot(ndvi_projected)
plot(slope)
plot(veg_herby)
plot(canopy_cover)

```

# Generating the data to fit a deepSSF model

## Set up the spatial extent of the local covariates

```{r}

# create a vector of ids
buffalo_ids <- unique(buffalo_all$id)

# get the resolution from the covariates
res <- terra::res(ndvi_projected)[1]

# how much to trim on either side of the location, 
# this will determine the extent of the spatial inputs to the deepSSF model
buffer <- 1250 + (res/2)
# calculate the number of cells in each axis
nxn_cells <- buffer*2/res

# hourly lag - to set larger time differences between locations
hourly_lag <- 1

```

Import the data that was used to train the deepSSF model

```{r}

data_id2005 <- read_csv("buffalo_local_data_id/buffalo_2005_data_df_lag_1hr_n10297.csv")

```

# Evaluate next-step ahead predictions

## Create distance and bearing layers for the movement probability

```{r}

image_dim <- 101
pixel_size <- 25
center <- image_dim %/% 2

# Create matrices of indices
x <- matrix(rep(0:(image_dim - 1), image_dim), nrow = image_dim, byrow = TRUE)
y <- matrix(rep(0:(image_dim - 1), each = image_dim), nrow = image_dim, byrow = TRUE)

# Compute the distance layer
distance_layer <- sqrt((pixel_size * (x - center))^2 + (pixel_size * (y - center))^2)

# Change the center cell to the average distance from the center to the edge of the pixel
distance_layer[center + 1, center + 1] <- 0.56 * pixel_size

# Compute the bearing layer
bearing_layer <- atan2(center - y, x - center)

# Convert the distance and bearing matrices to raster layers
distance_layer <- rast(distance_layer)
bearing_layer <- rast(bearing_layer)

# Optional: Plot the distance and bearing rasters
plot(distance_layer, main = "Distance from Center")
plot(bearing_layer, main = "Bearing from Center")

distance_values <- terra::values(distance_layer)
bearing_values <- terra::values(bearing_layer)

```

## Import SSF coefficients

```{r}

ssf_coefs <- read_csv("ssf_coefficients/TwoStep_0pDaily_coefs_dry_2024-09-05.csv")

# keep only the integer hours using the modulo operator
ssf_coefs <- ssf_coefs %>% filter(ssf_coefs$hour %% 1 == 0) #%>% 
  # change the 0th hour to 24
  # mutate(hour = ifelse(hour == 0, 24, hour))

head(ssf_coefs)

```


```{r}

test_data <- data_id2005 %>% slice(1:100)

n <- nrow(test_data)

pb <- progress_bar$new(
  format = "  Progress [:bar] :percent in :elapsed",
  total = n,
  clear = FALSE
)


tic()

for (i in 2:n) {
  
  sample_tm1 <- test_data[i-1, ] # get the step at t - 1 for the bearing of the approaching step
  sample <- test_data[i, ]
  sample_extent <- ext(sample$x_min, sample$x_max, sample$y_min, sample$y_max)
  
  # get the local covariate layers for the sample
  ndvi_index <- which.min(abs(difftime(sample$t_, terra::time(ndvi_projected))))
  ndvi_sample <- crop(ndvi_projected[[ndvi_index]], sample_extent)
  # plot(ndvi_sample)
  canopy_sample <- crop(canopy_cover, sample_extent)
  # plot(canopy_sample)
  veg_herby_sample <- crop(veg_herby, sample_extent)
  # plot(veg_herby_sample)
  slope_sample <- crop(slope, sample_extent)
  # plot(slope_sample)
  
  
  ### calculate the next-step probability surface
  
  # get the coefficients for the appropriate hour
  coef_hour <- which(ssf_coefs$hour == sample$hour_t2)
  
  # ndvi
  ndvi_linear <- ndvi_sample * ssf_coefs$ndvi[[coef_hour]]
  ndvi_quad <- ndvi_sample^2 * ssf_coefs$ndvi_2[[coef_hour]]
  
  # canopy cover 
  canopy_linear <- (canopy_sample/100) * ssf_coefs$canopy[[coef_hour]]
  canopy_quad <- (canopy_sample/100)^2 * ssf_coefs$canopy_2[[coef_hour]]
  
  # veg_herby
  veg_herby_pred <- veg_herby_sample * ssf_coefs$herby[[coef_hour]]
  
  # veg_herby
  slope_pred <- slope_sample * ssf_coefs$slope[[coef_hour]]
  
  # combining all covariates (on the log-scale)
  habitat_pred <- ndvi_linear + ndvi_quad + canopy_linear + canopy_quad + slope_pred + veg_herby_pred
  # plot(habitat_pred)
  
  
  # movement probability
  
  # step lengths
  # calculated on the log scale
  step_pred <- habitat_pred
  step_pred[] <- dgamma(distance_values, shape = ssf_coefs$shape[[coef_hour]], scale = ssf_coefs$scale[[coef_hour]], log = TRUE)
  # plot(step_pred)
  
  # turning angles
  ta_pred <- habitat_pred
  vm_mu <- sample$bearing
  vm_mu_updated <- ifelse(ssf_coefs$kappa[[coef_hour]] > 0, sample_tm1$bearing, sample_tm1$bearing - pi)
  ta_pred[] <- suppressWarnings(circular::dvonmises(bearing_values, mu = vm_mu_updated, kappa = abs(ssf_coefs$kappa[[coef_hour]]), log = TRUE))
  # plot(ta_pred)
  
  # combine the step and turning angle probabilities
  move_pred <- step_pred + ta_pred
  # plot(move_pred)
  
  # calculate the log next-step probability
  next_step_log <- habitat_pred + move_pred
  # plot(next_step_log)
  
  
  # calculate next-step probability
  
  # create template raster
  next_step_pred <- habitat_pred
  # normalise using log-sum-exp trick
  next_step_pred[] <- exp(values(next_step_log) - max(values(next_step_log))) / 
    sum(exp(values(next_step_log) - max(values(next_step_log))))
  # plot(next_step_pred)
  # sum(values(next_step_pred))
  
  # create a SpatVector from the coordinates
  next_step_vect <- vect(cbind(sample$x2_, sample$y2_), crs = crs(ndvi_sample))
  
  # check next-step location
  next_step_sample <- terra::mask(next_step_pred, next_step_vect, inverse = T)
  # plot(next_step_sample)
  
  # probability value at the next step
  prob_next_step <- as.numeric(terra::extract(next_step_pred, next_step_vect)[2])
  # print(prob_next_step)
  
  test_data[i, "prob_next_step_ssf"] <- prob_next_step
  
  pb$tick()  # Update progress bar
  
}

toc()

```

Plotting the next-step probabilities

```{r}

ggplot() +
  geom_line(data = test_data, 
            aes(x = t_, y = prob_next_step_ssf)) +
  theme_bw()

ggplot() +
  geom_point(data = test_data, 
             aes(x = hour_t2, y = prob_next_step_ssf, colour = yday_t2), 
             alpha = 0.5) +
  scale_colour_viridis_c() +
  theme_bw()

```


Loop over each individual and save the local rasters

```{r}

for(i in 1:length(buffalo_ids)) {

  buffalo_data <- buffalo_all %>% filter(id == buffalo_ids[i])
  # all data for that individual
  buffalo_data <- buffalo_data %>% arrange(t_)
  # a subset of the data for that individual - mostly for testing
  # buffalo_data <- buffalo_data %>% arrange(t_) |>  slice(1:1000)
  
  n_samples <- nrow(buffalo_data)
  
  tic()
  
  buffalo_data_covs <- buffalo_data %>% mutate(
    
    x1_ = x_,
    y1_ = y_,
    x2_ = lead(x1_, n = hourly_lag, default = NA),
    y2_ = lead(y1_, n = hourly_lag, default = NA),
    x2_cent = x2_ - x1_,
    y2_cent = y2_ - y1_,
    t2_ = lead(t_, n = hourly_lag, default = NA),
    t_diff = round(difftime(t2_, t_, units = "hours"),0),
    hour_t1 = lubridate::hour(t_),
    yday_t1 = lubridate::yday(t_),
    hour_t2 = lubridate::hour(t2_),
    hour_t2_sin = sin(2*pi*hour_t2/24),
    hour_t2_cos = cos(2*pi*hour_t2/24),
    yday_t2 = lubridate::yday(t2_),
    yday_t2_sin = sin(2*pi*yday_t2/365.25),
    yday_t2_cos = cos(2*pi*yday_t2/365.25),
    
    sl = c(sqrt(diff(y_)^2 + diff(x_)^2), NA),
    log_sl = log(sl),
    bearing = c(atan2(diff(y_), diff(x_)), NA),
    bearing_sin = sin(bearing),
    bearing_cos = cos(bearing),
    ta = c(NA, ifelse(
      diff(bearing) > pi, diff(bearing)-(2*pi), ifelse(
        diff(bearing) < -pi, diff(bearing)+(2*pi), diff(bearing)))),
    cos_ta = cos(ta),
      
    # extent for cropping the spatial covariates
    x_min = x_ - buffer,
    x_max = x_ + buffer,
    y_min = y_ - buffer,
    y_max = y_ + buffer,
    
  
    # crop out and store the local covariates centered on the animal's location 
    # with an extent set in the previous chunk
  ) %>% rowwise() %>% mutate(

    extent_00centre = list(ext(x_min - x_, x_max - x_, y_min - y_, y_max - y_)),

    # NDVI
    ndvi_index = which.min(abs(difftime(t_, terra::time(ndvi_projected)))),
    ndvi_cent = list({
      ndvi_cent = crop(ndvi_projected[[ndvi_index]], ext(x_min, x_max, y_min, y_max))
      ext(ndvi_cent) <- extent_00centre
      ndvi_cent
      }),

    # herbaceous vegetation
    veg_herby_cent = list({
      veg_herby_cent = crop(veg_herby, ext(x_min, x_max, y_min, y_max))
      ext(veg_herby_cent) <- extent_00centre
      veg_herby_cent
      }),

    # canopy cover
    canopy_cover_cent = list({
      canopy_cover_cent = crop(canopy_cover, ext(x_min, x_max, y_min, y_max))
      ext(canopy_cover_cent) <- extent_00centre
      canopy_cover_cent
      }),

    # slope
    
    slope_cent = list({
      slope_cent <- crop(slope, ext(x_min, x_max, y_min, y_max))
      ext(slope_cent) <- extent_00centre
      slope_cent
      }),

    # rasterised location of the next step - centred on (0,0)
    points_vect_cent = list(terra::vect(cbind(x2_ - x_, y2_ - y_), type = "points", crs = "EPSG:3112")),
    pres_cent = list(rasterize(points_vect_cent, ndvi_cent, background=0))

  ) %>% ungroup() # to remove the 'rowwise' class


  toc()

  # remove steps that fall outside of the local spatial extent
  buffalo_data_covs <- buffalo_data_covs %>%
    filter(x2_cent > -buffer & x2_cent < buffer & y2_cent > -buffer & y2_cent < buffer) %>%
    drop_na(ta)


  buffalo_data_df <- buffalo_data_covs %>%
  dplyr::select(-extent_00centre,
                -ndvi_cent,
                -veg_herby_cent,
                -canopy_cover_cent,
                -slope_cent,
                -points_vect_cent,
                -pres_cent
                )

  # save the data
  write_csv(buffalo_data_df, paste0("buffalo_local_data_id/buffalo_", buffalo_ids[i],
                                    "_data_df_lag_", hourly_lag, "hr_n", n_samples, ".csv"))

  # saving the raster objects
  rast(buffalo_data_covs$ndvi_cent) %>%
    writeRaster(paste0("buffalo_local_layers_id/buffalo_", buffalo_ids[i], "_ndvi_cent",
                       nxn_cells, "x", nxn_cells, "_lag_", hourly_lag, "hr_n", n_samples, ".tif"),
                overwrite = T)

  rast(buffalo_data_covs$veg_herby_cent) %>%
    writeRaster(paste0("buffalo_local_layers_id/buffalo_", buffalo_ids[i], "_herby_cent",
                       nxn_cells, "x", nxn_cells, "_lag_", hourly_lag, "hr_n", n_samples, ".tif"),
                overwrite = T)

  rast(buffalo_data_covs$canopy_cover_cent) %>%
    writeRaster(paste0("buffalo_local_layers_id/buffalo_", buffalo_ids[i], "_canopy_cent",
                       nxn_cells, "x", nxn_cells, "_lag_", hourly_lag, "hr_n", n_samples, ".tif"),
                overwrite = T)

  rast(buffalo_data_covs$slope_cent) %>%
    writeRaster(paste0("buffalo_local_layers_id/buffalo_", buffalo_ids[i], "_slope_cent",
                       nxn_cells, "x", nxn_cells, "_lag_", hourly_lag, "hr_n", n_samples, ".tif"),
                overwrite = T)

  rast(buffalo_data_covs$pres_cent) %>%
    writeRaster(paste0("buffalo_local_layers_id/buffalo_", buffalo_ids[i], "_pres_cent",
                       nxn_cells, "x", nxn_cells, "_lag_", hourly_lag, "hr_n", n_samples, ".tif"),
                overwrite = T)
  
}

```

## Check the outputs

```{r}

head(buffalo_data_covs)
which(is.na(buffalo_data_covs$ta))

```

## Plot a subset of the local covariates

```{r}

n_plots <- 5

walk(buffalo_data_covs$ndvi_cent[1:n_plots], plot)
walk(buffalo_data_covs$veg_herby_cent[1:n_plots], terra::plot)
walk(buffalo_data_covs$canopy_cover_cent[1:n_plots], terra::plot)
walk(buffalo_data_covs$slope_cent[1:n_plots], terra::plot)
walk(buffalo_data_covs$pres_cent[1:n_plots], terra::plot)

saveRDS(buffalo_data_covs, paste0("buffalo_data_id_covs_", Sys.Date(), ".rds"))

```

## To save some plots

```{r}

# for(i in 1:n_plots) {
#   png(filename = paste0("ndvi_cent_", i, ".png"),
#       width = 150, height = 150, units = "mm", res = 600)
#   terra::plot(buffalo_data_covs$ndvi_cent[[i]])
#   dev.off()
# }
# 
# # for the pres layers
# for(i in 1:n_plots) {
#   
#   # change the 0 values to NA
#   layer <- buffalo_data_covs$pres_cent[[i]]
#   layer[layer == 0] <- 0.5
#   
#   ndvi_layer <- buffalo_data_covs$ndvi_cent[[i]]
#   new_layer <- layer*ndvi_layer
#   
#   # save the plot
#   png(filename = paste0("pres_cent_", i, ".png"),
#       width = 150, height = 150, units = "mm", res = 600)
#   terra::plot(new_layer)
#   dev.off()
# }
# 
# 
# # other plots
# 
# n_plots <- 1
# 
# for(i in 1:n_plots) {
#   png(filename = paste0("veg_herby_cent_", i, ".png"),
#       width = 150, height = 150, units = "mm", res = 600)
#   terra::plot(buffalo_data_covs$veg_herby_cent[[i]])
#   dev.off()
# }
# 
# for(i in 1:n_plots) {
#   png(filename = paste0("canopy_cover_cent_", i, ".png"),
#       width = 150, height = 150, units = "mm", res = 600)
#   terra::plot(buffalo_data_covs$canopy_cover_cent[[i]])
#   dev.off()
# }
# 
# for(i in 1:n_plots) {
#   png(filename = paste0("slope_cent_", i, ".png"),
#       width = 150, height = 150, units = "mm", res = 600)
#   terra::plot(buffalo_data_covs$slope_cent[[i]])
#   dev.off()
# }

```

# Plotting for CDS/ESA presentations

```{r}

t <- 1:10
x <- rep(1, length(t))

ggplot() +
  geom_point(aes(x = t, y = x), size = 1) +
  scale_x_continuous(limits = c(0, 11), breaks = 1:10) +
  scale_y_continuous("GPS Fix", limits = c(0.5, 1.5), breaks = 1) +
  theme_classic()

ggsave("outputs/fix_sequence.png", height = 30, width = 120, units = "mm", dpi = 600)


```



```{r}

# plot step lengths
buffalo_data_covs %>% filter(sl < 2000) %>% ggplot() +
  geom_density(aes(x = sl), #, bins = 50
                 fill = "skyblue", colour = "skyblue", alpha = 0.75) +
  scale_x_continuous("Step length (m)") + #, limits = c(-25, 1250)
  scale_y_continuous("Density") +
  ggtitle("Step lengths") +
  theme_classic()

ggsave("outputs/step_length.png", height = 60, width = 120, units = "mm", dpi = 600)


# plot turning angles
buffalo_data_covs %>% ggplot() +
  geom_density(aes(x = ta), 
                 fill = "skyblue", colour = "skyblue", alpha = 0.75) +
  # scale_x_continuous(breaks = c(expression(pi))) + #, limits = c(-180, 180)
  scale_x_continuous("Turning angle (radians)", 
    breaks = c(-pi, -pi/2, 0, pi/2, pi),
    labels = c(expression(-pi), expression(-pi/2), "0", expression(pi/2), expression(pi))
  ) +
  scale_y_continuous("Density") +
  ggtitle("Turning angles") +
  theme_classic()

ggsave("outputs/turning_angle.png", height = 60, width = 120, units = "mm", dpi = 600)  

```

